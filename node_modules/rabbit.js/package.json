{
  "name": "rabbit.js",
  "description": "Easy stream-based messaging using RabbitMQ",
  "version": "0.3.1",
  "homepage": "http://github.com/squaremo/rabbit.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/squaremo/rabbit.js.git"
  },
  "author": {
    "name": "Michael Bridgen",
    "email": "mikeb@squaremobius.net"
  },
  "directories": {
    "lib": "lib",
    "test": "test"
  },
  "main": "./index",
  "scripts": {
    "test": "./node_modules/mocha/bin/mocha --ui exports test"
  },
  "engines": {
    "node": "0.8 || 0.10"
  },
  "dependencies": {
    "amqplib": "0.1",
    "node-uuid": "",
    "readable-stream": "~1 >=1.0.2"
  },
  "devDependencies": {
    "mocha": ""
  },
  "readme": "# Messaging in Node.JS with RabbitMQ\n\n    $ npm install rabbit.js\n\nThis library provides a simple, socket-oriented API* for messaging in\n[Node.JS](http://nodejs.org/), using\n[RabbitMQ](http://www.rabbitmq.com/) as a backend.\n\n```js\nvar context = require('rabbit.js').createContext();\ncontext.on('ready', function() {\n  var pub = context.socket('PUB'), sub = context.socket('SUB');\n  sub.pipe(process.stdout);\n  sub.connect('events', function() {\n    pub.connect('events', function() {\n      pub.write(JSON.stringify({welcome: 'rabbit.js'}), 'utf8');\n    });\n  });\n});\n```\n\n*Yes, rather like ZeroMQ. [See below](#zeromq).\n\n## Status\n\nStill on major version `0`, though in use in a number of places, I\nbelieve.\n\nVersion 0.3.0 and on are built on [amqplib][]. Previous versions, of\nwhich v0.2.2 was the last, used [node-amqp][].\n\n## Uses\n\nThis library is suitable for co-ordinating peers (e.g., Node.JS\nprograms), acting as a gateway to other kinds of network (e.g.,\nrelaying to browsers via SockJS), and otherwise as a really easy way\nto use RabbitMQ.\n\n## API\n\nThe entry point is `createContext`, which gives you a factory for\nsockets. You supply it the URL to your RabbitMQ server:\n\n```js\nvar context = require('rabbit.js').createContext('amqp://localhost');\n```\n\nThe context will emit `'ready'` when it's connected.\n\nA context will emit `'error'` with an `Error` object if there's a\nproblem with the underlying connection to the server. This invalidates\nthe context and all its sockets.\n\nA context may be disconnected from the server with `#close()`. It will\nemit `'close'` once the underlying connection has been terminated, by\nyou or by an error.\n\n### Sockets\n\nTo start sending or receiving messages you need to acquire a socket:\n\n```js\nvar pub = context.socket('PUB');\nvar sub = context.socket('SUB');\n```\n\nand connect it to something:\n\n```js\npub.connect('alerts');\nsub.connect('alerts');\n```\n\nSockets are [Streams][nodejs-stream] in object mode, with buffers as\nthe objects. In particular, you can `#read()` buffers from those that\nare readable, and you can `#write()` to those that are writable. If\nyou're using strings, you can `setEncoding()` to get strings instead\nof buffers as data, and supply the encoding when writing.\n\n```js\nsub.setEncoding('utf8');\nsub.on('data', function(note) { console.log(\"Alarum! \" + note); });\n\npub.write(\"Emergency. There's an emergency going on\", 'utf8');\n```\n\nYou can also use `#pipe` to forward messages to or from another\nstream, making relaying simple:\n\n```js\nsub.pipe(process.stdout);\n```\n\nA socket may be connected more than once, by calling\n`socket.connect(x)` with different `x`s. What this entails depends on\nthe socket type (see below). Messages to and from different\n`connect()`ions are not distinguished. For example\n\n```js\nvar sub2 = context.socket('SUB');\nsub2.connect('system');\nsub2.connect('notifications');\n```\n\nHere, the socket `sub2` will receive all messages published to\n`'system'` and all those published to `'notifications'` as well, but\nit is not possible to distinguish among the sources. If you want to do\nthat, use distinct sockets.\n\n#### `Socket#setsockopt`\n\nSome socket types have options that may be set with\n`#setsockopt`. Presently there's just one option, on PUB, PUSH, REQ\nand REP sockets, which is message expiration, given as a number of\nmilliseconds:\n\n```js\npub.setsockopt('expiration', 60 * 1000)\n```\n\nIn the example, messages written to `pub` will be discarded by the\nserver if they've not been delivered after 60,000\nmilliseconds. Message expiration only works with versions of RabbitMQ\nnewer than 3.0.0.\n\nYou need to be careful when using expiry with a **REQ** or **REP**\nsocket, since losing a request or reply will break ordering. Only\nsending one request at a time, and giving requests a time limit, may\nhelp.\n\n#### `Socket#close` and `Socket#end`\n\nA socket may be closed using `#close()`; this will clean up resources,\nand emit `'close'` once it's done so.\n\nA writable socket may be closed with a final write by calling\n`#end([chunk [, encoding]])`.\n\n### Socket types\n\nThe socket types, passed as an argument to `Context#socket`,\ndetermines whether the socket is readable and writable, and what\nhappens to buffers written to it. Socket types (but not necessarily\nsockets themselves) should be used in the pairs described below.\n\nTo make the descriptions a bit easier, we'll say if `connect(x)` is\ncalled on a socket for some <x>, the socket is connected to x and x is\na connection of the socket.\n\n**PUB**lish / **SUB**scribe: every SUB socket connected to <x> gets\neach message sent by a PUB socket connected to <x>; a PUB socket\nsends every message to each of its connections. SUB sockets are\nreadable only, and PUB sockets are writable only.\n\n**PUSH** / **PULL**: a PUSH socket will send each message to a\nsingle connection, using round-robin. A PULL socket will receive a\nshare of the messages sent to each <y> to which it is connected,\ndetermined by round-robin at <y>. PUSH sockets are writable only, and\nPULL sockets are readable only.\n\n**REQ**uest / **REP**ly: a REQ socket sends each message to one of its\nconnections, and receives replies in turn; a REP socket receives a\nshare of the messages sent to each <y> to which it is connected, and\nmust send a reply for each, in the order they come in. REQ and REP\nsockets are both readable and writable.\n\n## Using with servers\n\nA few modules have a socket-server-like abstraction; canonically, the\n`net` module, but also for example SockJS and Socket.IO. These can be\nadapted using something similar to the following.\n\n```js\nvar context = new require('rabbit.js').createContext('amqp://localhost');\nvar inServer = net.createServer(function(connection) {\n  var s = context.socket('PUB');\n  s.connect('incoming', function() {\n    connection.pipe(s);\n  });\n});\ninServer.listen(5000);\n```\n\nThis is a simplistic example: a bare TCP socket won't in general emit\ndata in chunks that are meaningful to applications, even if they are\nsent that way at the far end.\n\n## Examples\n\nEach subdirectory of `example` has code demonstrating using\nrabbit.js with other modules. Install the prerequisites for rabbit.js\nfirst:\n\n    rabbit.js$ npm install\n\nNow each example can be run with, e.g.,\n\n    rabbit.js$ cd example/sockjs\n    sockjs$ npm install && npm start\n\nAll of the examples assume there is a [RabbitMQ server\nrunning](http://rabbit.mq/download.html) locally. The SockJS and\nSocket.IO examples both start a website which you can visit at\n`http://localhost:8080`.\n\n## <a name=\"zeromq\"></a>Relation to ZeroMQ\n\nrabbit.js was inspired by the [RabbitMQ/ZeroMQ\nadapter](http://github.com/rabbitmq/rmq-0mq/) I developed with Martin\nSÃºstrik. The rationale for using RabbitMQ in a ZeroMQ-based network is\nlargely transferable to rabbit.js:\n\n * RabbitMQ introduces a degree of monitoring and transparency,\n   especially if one uses the web management app;\n * RabbitMQ can bridge to other protocols (notably AMQP and STOMP);\n * RabbitMQ provides reliable, persistent queues if desired\n\nwith some additional benefits:\n\n * since rabbit.js sockets implement the `Stream` interface, one\n   can easily pipe messages around\n * using RabbitMQ as a backend obviates some configuration management\n   -- just supply all instances the broker URL and you're good to go.\n * there's room in the API for more involved routing and other\n   behaviour since AMQP is, well, more complicated let's say.\n\nHere are some notable differences and similarities to ZeroMQ in\nrabbit.js's API and semantics.\n\nTo start, there's no distinction in rabbit.js between clients and\nservers (`connect` and `bind` in ZeroMQ, following the BSD socket\nAPI), since RabbitMQ is effectively acting as a relaying server for\neveryone to `connect` to. Relatedly, the argument supplied to\n`connect()` is abstract, in the sense that it's just a name rather\nthan a transport-layer address.\n\nRequest and Reply sockets have very similar semantics to those in\nZeroMQ. Repliers must respond to requests in the order that they come\nin, and respond exactly once to each request.\n\nThere are no DEALER or ROUTER sockets (a.k.a., XREQ and XREQ) in\nrabbit.js. In ZeroMQ these are implemented by prefixing messages with\na reverse path, which then requires encoding and thereby complication\nwhen relaying to other streams or protocols. Instead, rabbit.js notes\nthe reverse path as messages are relayed to a REP socket, and\nreapplies it when the response appears (giving rise to the ordering\nrequirement on replies).\n\n## Relation to AMQP and STOMP\n\nrabbit.js makes some simplifying assumptions that must be kept in mind\nwhen integrating with other protocols that RabbitMQ supports.\n\nPUB and SUB sockets declare non-durable fanout exchanges named for the\nargument given to `connect`. To send to SUB sockets or receive from\nPUB sockets, publish or bind (or subscribe in the case of STOMP) to\nthe exchange with the same name.\n\nPUSH, PULL, REQ and REP sockets use durable, non-exclusive queues\nnamed for the argument given to `connect`. If you are replying via\nAMQP or STOMP, be sure to follow the convention of sending the\nresponse to the queue given in the `'replyTo'` property of the request\nmessage, and copying the `'correlationId'` property from the request\nin the reply. If you are requesting via AMQP or STOMP, at least supply\na `replyTo`, and consider supplying a `correlationId`.\n\n[amqplib]: https://github.com/squaremo/amqp.node/\n[node-amqp]: https://github.com/postwait/node-amqp/\n[nodejs-stream]: http://nodejs.org/docs/v0.10.21/api/stream.html\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/squaremo/rabbit.js/issues"
  },
  "_id": "rabbit.js@0.3.1",
  "dist": {
    "shasum": "955a4401b6cf11544afff75ab7fc22404a17c41a"
  },
  "_from": "rabbit.js@",
  "_resolved": "https://registry.npmjs.org/rabbit.js/-/rabbit.js-0.3.1.tgz"
}
